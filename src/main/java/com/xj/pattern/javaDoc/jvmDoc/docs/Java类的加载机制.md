# JAVA类的加载机制

## Java类加载分为5个过程：加载、连接(验证，准备，解析)、初始化、使用、卸载

![](C:\Users\junxu\Desktop\jvm\images\类加载.jpg)

### 1.加载


加载主要是将.class文件（也可以是zip包）通过二进制字节流读入到JVM中，在加载阶段，JVM要完成三件事：

- 通过classLoader在classpath中获取XXX.class文件，将其以二进制流的形式读入内存。
- 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个该类的java.lang.class对象,作为方法区这个类的各种数据的访问入口

### 2.连接

2.1验证：主要确保加载进来的字节流符号JVM规范，研制阶段会完成以下四个阶段的检验动作

- 文件格式验证
- 元数据验证（是否符号Java语法规范）
- 字节码验证（确定程序语义合法，符号逻辑）
- 符号引用验证（确保下一步的解析能正常执行）

2.2准备：准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值

2.3解析：解析是连接阶段的第三步，是虚拟机将常量池内的符号引用替换为直接引用的过程

### 3.初始化

初始化阶段是类加载过程的最后一步，*主要是根据程序中的赋值语句主动为类变量赋值*。

当有继承关系的时，先初始化父类再初始化子类，所以创建一个子类时其实内存中存在两个实例对象。

*PS：*如果类的继承关系过长，单从类初始化角度考虑，这种设计不太可取。通常建议的类继承关系不超过三层，即 父-子-孙。

某些特殊的场景中可能会加到4层，但就此打住，第4层已经有代码设计上的弊端了。

### 4.使用

程序直接的相互调用

### 5.卸载

即销毁一个对象，一般情况下由JVM垃圾回收器完成回收。代码层面的销毁只是将引用置为null。

## 类加载器

JVM提供了以下3中系统的类加载器：

- **启动类加载器【Bootstrap ClassLoader】**：最顶层的类加载器，负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
- **扩展类加载器【Extension ClassLoader】**：负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
- **应用程序类加载器【Application ClassLoader】**：也叫做系统类加载器，可以通过getSystemClassLoader()获取，负责加载用户路径（classpath）上的类库。如果没有自定义类加载器，一般这个就是默认的类加载器。



### 类加载做的事情

1. 类加载，同时初始化类中静态的属性（赋默认值）
2. 执行静态代码块
3. 分配内存空间，同时初始化非静态的属性
4. 如果声明属性的同时又显示的赋值，那么进行显示赋值把默认值覆盖
5. 执行匿名代码块
6. 执行构造器
7. 返回内存地址

### 类加载的顺序

1. **static 变量**
2. **static 代码块**
3. **成员变量**
4. **匿名块**
5. **构造器**

**PS：先加载父类，再加载子类**

**具体继承类（父-子）：**

**1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。** 
**2、执行子类的静态代码块和静态变量初始化。** 
**3、执行父类的实例变量初始化** 
**4、执行父类的构造函数** 
**5、执行子类的实例变量初始化** 
**6、执行子类的构造函数** 































